import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, CallbackQueryHandler
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
import asyncio
import json
import os


# Loglama ayarlarƒ±
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Telegram Bot Token
TOKEN = "BOTFATHER'DAN_ALDIƒûINIZ_TOKEN"

# Hisse fiyatƒ± √ßekme fonksiyonu
async def get_stock_price(symbol):
    def _get_price():
        # Selenium ayarlarƒ±
        chrome_options = Options()
        chrome_options.add_argument("--headless")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")

        # ChromeDriver'ƒ± otomatik kur
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)

        try:
            #  hisse senedi sayfasƒ±nƒ± a√ß
            url = f"Senin_Web_Scraping_Linkin"
            driver.get(url)

            # Fiyat deƒüerini √ßek
            price_element = WebDriverWait(driver, 20).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, "span.js-symbol-last"))
            )
            price = price_element.text.strip()
            
            return price, None
        except Exception as e:
            return None, str(e)
        finally:
            driver.quit()
    
    # Selenium i≈ülemini thread pool ile √ßalƒ±≈ütƒ±r (blocking i≈ülem)
    loop = asyncio.get_running_loop()
    price, error = await loop.run_in_executor(None, _get_price)
    
    if price:
        return f"{symbol} i√ßin son fiyat: {price}"
    else:
        return f"{symbol} i√ßin fiyat bulunamadƒ±. Hata: {error}"

# Bot komutlarƒ±
async def start(update: Update, context: CallbackContext) -> None:
    user = update.effective_user
    await update.message.reply_text(
        f"Merhaba {user.first_name}! Hisse Fiyatlarƒ± Botuna ho≈ü geldiniz."
    )
    await show_main_menu(update, context)

async def help_command(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text(
        "Kullanƒ±m:\n"
        "- Hisse fiyatƒ±nƒ± √∂ƒürenmek i√ßin bir hisse sembol√º g√∂nderin (√∂rn. AKBNK)\n"
        "- /start - Ana men√ºy√º g√∂ster\n"
        "- /help - Yardƒ±m mesajƒ±nƒ± g√∂ster\n"
        "- /menu - Ana men√ºy√º g√∂ster\n"
        "- /favoriler - Favori hisselerinizi g√∂sterir\n"
        "- /ekle [SEMBOL] - Favorilere hisse ekle\n"
    )
    await show_main_menu(update, context)

# Kullanƒ±cƒ±nƒ±n favori hisseleri (ger√ßek uygulamada veritabanƒ±nda saklanabilir)
favorites = {
    # user_id: [sembol1, sembol2, ...]
}

# Kullanƒ±cƒ±nƒ±n portf√∂y√º (JSON dosyasƒ±na kaydedilecek)
portfolio = {
    # user_id: {symbol: {'price': alƒ±m_fiyatƒ±, 'quantity': adet}, ...}
}

# Portf√∂y dosyasƒ±
PORTFOLIO_FILE = "portfolio_data.json"

# Portf√∂y√º y√ºkle
def load_portfolio():
    global portfolio
    try:
        if os.path.exists(PORTFOLIO_FILE):
            with open(PORTFOLIO_FILE, "r", encoding="utf-8") as file:
                # JSON'dan string olan kullanƒ±cƒ± ID'leri int'e √ßevirme
                data = json.load(file)
                portfolio = {int(user_id): user_data for user_id, user_data in data.items()}
            print("Portf√∂y verileri ba≈üarƒ±yla y√ºklendi.")
    except Exception as e:
        print(f"Portf√∂y y√ºklenirken hata olu≈ütu: {e}")
        portfolio = {}

# Bildirim tercihlerini y√ºkle
def load_notification_preferences():
    global notification_preferences
    try:
        if os.path.exists(NOTIFICATION_PREFS_FILE):
            with open(NOTIFICATION_PREFS_FILE, "r", encoding="utf-8") as file:
                # JSON'dan string olan kullanƒ±cƒ± ID'leri int'e √ßevirme
                data = json.load(file)
                notification_preferences = {int(user_id): user_data for user_id, user_data in data.items()}
            print("Bildirim tercihleri ba≈üarƒ±yla y√ºklendi.")
    except Exception as e:
        print(f"Bildirim tercihleri y√ºklenirken hata olu≈ütu: {e}")
        notification_preferences = {}

# Portf√∂y√º kaydet
def save_portfolio():
    try:
        # int olan kullanƒ±cƒ± ID'lerini string'e √ßevirme (JSON uyumluluƒüu i√ßin)
        data = {str(user_id): user_data for user_id, user_data in portfolio.items()}
        with open(PORTFOLIO_FILE, "w", encoding="utf-8") as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        print("Portf√∂y verileri ba≈üarƒ±yla kaydedildi.")
    except Exception as e:
        print(f"Portf√∂y kaydedilirken hata olu≈ütu: {e}")

# Bildirim tercihlerini kaydet
def save_notification_preferences():
    try:
        # int olan kullanƒ±cƒ± ID'lerini string'e √ßevirme (JSON uyumluluƒüu i√ßin)
        data = {str(user_id): user_data for user_id, user_data in notification_preferences.items()}
        with open(NOTIFICATION_PREFS_FILE, "w", encoding="utf-8") as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        print("Bildirim tercihleri ba≈üarƒ±yla kaydedildi.")
    except Exception as e:
        print(f"Bildirim tercihleri kaydedilirken hata olu≈ütu: {e}")
        
# Kullanƒ±cƒ±nƒ±n bildirim tercihlerini ayarla
def set_notification_preference(user_id, enabled=True):
    if user_id not in notification_preferences:
        notification_preferences[user_id] = {"enabled": enabled, "last_notification": None}
    else:
        notification_preferences[user_id]["enabled"] = enabled
    
    save_notification_preferences()
    
    # Scheduled Notifications mod√ºl√ºne bildir
    try:
        from scheduled_notifications import register_user_for_notifications, unregister_user_from_notifications
        if enabled:
            register_user_for_notifications(user_id)
        else:
            unregister_user_from_notifications(user_id)
    except ImportError:
        print("scheduled_notifications mod√ºl√º y√ºklenemedi.")

# Kullanƒ±cƒ± durum takibi i√ßin
user_states = {}

# Bildirim alma tercihlerini takip eden s√∂zl√ºk
notification_preferences = {}
# Bildirim zamanlarƒ±nƒ± kaydetmek i√ßin dosya
NOTIFICATION_PREFS_FILE = "notification_prefs.json"

class ConversationState:
    IDLE = 0
    WAITING_FOR_STOCK = 1
    WAITING_FOR_PRICE = 2
    WAITING_FOR_QUANTITY = 3

async def add_favorite(update: Update, context: CallbackContext) -> None:
    user_id = update.effective_user.id
    
    if not context.args:
        await update.message.reply_text("L√ºtfen eklemek istediƒüiniz hisse sembol√ºn√º yazƒ±n. √ñrnek: /ekle AKBNK")
        return
    
    symbol = context.args[0].upper()
    
    if user_id not in favorites:
        favorites[user_id] = []
    
    if symbol in favorites[user_id]:
        await update.message.reply_text(f"{symbol} zaten favorilerinizde.")
    else:
        favorites[user_id].append(symbol)
        await update.message.reply_text(f"{symbol} favorilerinize eklendi.")

async def show_favorites(update: Update, context: CallbackContext) -> None:
    user_id = update.effective_user.id
    
    if user_id not in favorites or not favorites[user_id]:
        await update.message.reply_text("Hen√ºz favori hisseniz bulunmuyor.")
        return
    
    keyboard = []
    for symbol in favorites[user_id]:
        keyboard.append([InlineKeyboardButton(symbol, callback_data=f"fav_{symbol}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Favori hisseleriniz:", reply_markup=reply_markup)

async def button_callback(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    user_id = update.effective_user.id
    
    # Ana men√ºy√º g√∂ster
    if callback_data == "main_menu":
        await show_main_menu_from_callback(query, context)
    
    # Favorileri g√∂ster
    elif callback_data == "favorites":
        await show_favorites_from_callback(query, context)
    
    # Belirli bir hisse fiyatƒ±nƒ± g√∂ster
    elif callback_data.startswith("price_"):
        symbol = callback_data[6:]
        price_message = await get_stock_price(symbol)
        
        # Klavye d√ºƒümeleri
        keyboard = [
            [InlineKeyboardButton("‚≠ê Favorilere Ekle", callback_data=f"add_{symbol}")],
            [InlineKeyboardButton("üíº Portf√∂ye Ekle", callback_data=f"add_portfolio_{symbol}")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Geri", callback_data="favorites")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text=price_message, reply_markup=reply_markup)
    
    # Favorilere ekle
    elif callback_data.startswith("add_") and not callback_data.startswith("add_portfolio_"):
        symbol = callback_data[4:]
        
        if user_id not in favorites:
            favorites[user_id] = []
            
        if symbol not in favorites[user_id]:
            favorites[user_id].append(symbol)
            await query.edit_message_text(f"{symbol} favorilerinize eklendi!")
            await show_favorites_from_callback(query, context)
        else:
            await query.edit_message_text(f"{symbol} zaten favorilerinizde!")
            await show_favorites_from_callback(query, context)
    
    # Favorilerden √ßƒ±kar
    elif callback_data.startswith("remove_"):
        symbol = callback_data[7:]
        
        if user_id in favorites and symbol in favorites[user_id]:
            favorites[user_id].remove(symbol)
            await query.edit_message_text(f"{symbol} favorilerinizden √ßƒ±karƒ±ldƒ±!")
            await show_favorites_from_callback(query, context)
        else:
            await query.edit_message_text(f"{symbol} favorilerinizde bulunamadƒ±!")
            await show_favorites_from_callback(query, context)
    
    # Portf√∂ye ekle
    elif callback_data.startswith("add_portfolio_"):
        symbol = callback_data[14:]
        
        user_states[user_id] = ConversationState.WAITING_FOR_PRICE
        context.user_data["current_symbol"] = symbol
        
        await query.edit_message_text(
            f"{symbol} hissesi i√ßin alƒ±m fiyatƒ±nƒ± girin (√∂rn: 45.60):"
        )
    
    # Portf√∂y√º g√∂ster
    elif callback_data == "portfolio":
        await show_portfolio(query, context)
    
    # Portf√∂yden hisse √ßƒ±kar
    elif callback_data.startswith("remove_portfolio_"):
        symbol = callback_data[17:]
        
        if user_id in portfolio and symbol in portfolio[user_id]:
            del portfolio[user_id][symbol]
            save_portfolio()
            await query.edit_message_text(f"{symbol} portf√∂y√ºn√ºzden √ßƒ±karƒ±ldƒ±!")
            await show_portfolio(query, context)
        else:
            await query.edit_message_text(f"{symbol} portf√∂y√ºn√ºzde bulunamadƒ±!")
            await show_portfolio(query, context)
    
    # K√¢r-zarar durumu g√∂ster
    elif callback_data == "profit_loss":
        await show_profit_loss(query, context)
    
    # Kullanƒ±cƒ±nƒ±n kendi portf√∂y√ºn√º g√∂rmesi i√ßin
    elif callback_data == "my_portfolio":
        await show_portfolio(query, context)
        
    # Otomatik bildirimleri a√ß/kapat
    elif callback_data == "toggle_notifications":
        user_enabled = user_id in notification_preferences and notification_preferences[user_id].get("enabled", False)
        set_notification_preference(user_id, not user_enabled)
        
        status = "a√ßƒ±k" if not user_enabled else "kapalƒ±"
        await query.edit_message_text(
            f"Otomatik bildirimler {status} duruma getirildi. Hafta i√ßi saat 09:00-18:00 arasƒ±nda her saat ba≈üƒ± bildirim alacaksƒ±nƒ±z.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]])
        )
    
    # Bildirimleri durdur (bildirim i√ßinden gelen)
    elif callback_data == "stop_notifications":
        set_notification_preference(user_id, False)
        await query.edit_message_text(
            "Otomatik bildirimler kapatƒ±ldƒ±. ƒ∞stediƒüiniz zaman tekrar a√ßabilirsiniz.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]])
        )

async def handle_message(update: Update, context: CallbackContext) -> None:
    user_id = update.effective_user.id
    text = update.message.text.strip().upper()
    
    # Konu≈üma durumunu kontrol et
    if user_id in user_states:
        user_state = user_states[user_id]['state']
        
        # Hisse sembol√º bekleniyor
        if user_state == ConversationState.WAITING_FOR_STOCK:
            user_states[user_id]['data']['symbol'] = text
            user_states[user_id]['state'] = ConversationState.WAITING_FOR_PRICE
            
            keyboard = [[InlineKeyboardButton("ƒ∞ptal", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(
                f"{text} hissesinin alƒ±m fiyatƒ±nƒ± TL olarak giriniz (√∂rn. 45.60):",
                reply_markup=reply_markup
            )
            return
        
        # Hisse fiyatƒ± bekleniyor
        elif user_state == ConversationState.WAITING_FOR_PRICE:
            try:
                price = float(text.replace(',', '.'))
                user_states[user_id]['data']['price'] = price
                user_states[user_id]['state'] = ConversationState.WAITING_FOR_QUANTITY
                
                keyboard = [[InlineKeyboardButton("ƒ∞ptal", callback_data="main_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(
                    f"Ka√ß adet hisse aldƒ±ƒüƒ±nƒ±zƒ± giriniz (√∂rn. 100):",
                    reply_markup=reply_markup
                )
                return
            except ValueError:
                await update.message.reply_text(
                    "Ge√ßerli bir sayƒ± giriniz. √ñrnek: 45.60"
                )
                return
        
        # Hisse adedi bekleniyor
        elif user_state == ConversationState.WAITING_FOR_QUANTITY:
            try:
                quantity = int(text)
                symbol = user_states[user_id]['data']['symbol']
                price = user_states[user_id]['data']['price']
                
                # Portf√∂ye ekle
                if user_id not in portfolio:
                    portfolio[user_id] = {}
                
                portfolio[user_id][symbol] = {
                    'price': price,
                    'quantity': quantity
                }
                
                # Portf√∂y√º kaydet
                save_portfolio()
                
                # Kullanƒ±cƒ± durumunu sƒ±fƒ±rla
                del user_states[user_id]
                
                await update.message.reply_text(
                    f"{symbol} hissesi portf√∂y√ºn√ºze eklendi.\n" 
                    f"Alƒ±m Fiyatƒ±: {price} TL\n"
                    f"Adet: {quantity}\n"
                    f"Toplam: {price * quantity} TL"
                )
                
                # Ana men√ºy√º g√∂ster
                await show_main_menu(update, context)
                return
            except ValueError:
                await update.message.reply_text(
                    "Ge√ßerli bir sayƒ± giriniz. √ñrnek: 100"
                )
                return
    
    # √ñzel mesaj kontrol√º
    if text == "MENU" or text == "MEN√ú":
        await show_main_menu(update, context)
        return
        
    # Hisse sembol√º olarak kabul et
    await update.message.reply_text(f"{text} i√ßin fiyat alƒ±nƒ±yor...")
    result = await get_stock_price(text)
    
    # Sonucu g√∂ster ve tekrar men√º ekle
    keyboard = [
        [InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(result, reply_markup=reply_markup)

# Ana men√º fonksiyonu
async def show_main_menu(update: Update, context: CallbackContext) -> None:
    user_id = update.effective_user.id
    
    # Bildirim durumunu kontrol et
    notification_status = "Kapalƒ±"
    if user_id in notification_preferences and notification_preferences[user_id].get("enabled", False):
        notification_status = "A√ßƒ±k"
    
    keyboard = [
        [InlineKeyboardButton("‚≠ê Favoriler", callback_data="favorites")],
        [InlineKeyboardButton("üíº Portf√∂y√ºm", callback_data="portfolio")],
        [InlineKeyboardButton("üí∞ K√¢r/Zarar Durumu", callback_data="profit_loss")],
        [InlineKeyboardButton(f"üîî Otomatik Bildirimler ({notification_status})", callback_data="toggle_notifications")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "Ana Men√º",
        reply_markup=reply_markup
    )

# Callback query'den ana men√º g√∂sterme
async def show_main_menu_from_callback(query, context: CallbackContext) -> None:
    user_id = query.from_user.id
    
    # Bildirim durumunu kontrol et
    notification_status = "Kapalƒ±"
    if user_id in notification_preferences and notification_preferences[user_id].get("enabled", False):
        notification_status = "A√ßƒ±k"
    
    keyboard = [
        [InlineKeyboardButton("‚≠ê Favoriler", callback_data="favorites")],
        [InlineKeyboardButton("üíº Portf√∂y√ºm", callback_data="portfolio")],
        [InlineKeyboardButton("üí∞ K√¢r/Zarar Durumu", callback_data="profit_loss")],
        [InlineKeyboardButton(f"üîî Otomatik Bildirimler ({notification_status})", callback_data="toggle_notifications")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        "Ana Men√º",
        reply_markup=reply_markup
    )

# Callback query'den favorileri g√∂sterme
async def show_favorites_from_callback(query, context: CallbackContext) -> None:
    user_id = query.from_user.id
    
    if user_id not in favorites or not favorites[user_id]:
        keyboard = [[InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("Hen√ºz favori hisseniz bulunmuyor.", reply_markup=reply_markup)
        return
    
    keyboard = []
    for symbol in favorites[user_id]:
        keyboard.append([InlineKeyboardButton(symbol, callback_data=f"fav_{symbol}")])
    
    keyboard.append([InlineKeyboardButton("Ana Men√º", callback_data="main_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("Favori hisseleriniz:", reply_markup=reply_markup)

# Portf√∂y g√∂sterme fonksiyonu
async def show_portfolio(query, context: CallbackContext) -> None:
    user_id = query.from_user.id
    
    if user_id not in portfolio or not portfolio[user_id]:
        keyboard = [[InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("Hen√ºz portf√∂y√ºn√ºzde hisse bulunmuyor.", reply_markup=reply_markup)
        return
    
    # Portf√∂y bilgilerini hazƒ±rla
    portfolio_text = "üìä PORTF√ñY√úN√úZ:\n\n"
    total_investment = 0
    
    for symbol, data in portfolio[user_id].items():
        price = data['price']
        quantity = data['quantity']
        total = price * quantity
        total_investment += total
        
        portfolio_text += f"üî∏ {symbol}\n"
        portfolio_text += f"   Alƒ±m: {price} TL √ó {quantity} = {total:.2f} TL\n"
    
    portfolio_text += f"\nToplam Yatƒ±rƒ±m: {total_investment:.2f} TL"
    
    # Butonlarƒ± hazƒ±rla
    keyboard = []
    # Her hisse i√ßin bir silme butonu ekle
    for symbol in portfolio[user_id].keys():
        keyboard.append([InlineKeyboardButton(f"‚ùå {symbol} Sil", callback_data=f"delete_{symbol}")])
    
    keyboard.append([InlineKeyboardButton("üí∞ Gelir Durumu", callback_data="profit_loss")])
    keyboard.append([InlineKeyboardButton("Ana Men√º", callback_data="main_menu")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(portfolio_text, reply_markup=reply_markup)

# Portf√∂y komutu
async def portfolio_command(update: Update, context: CallbackContext) -> None:
    # Mesaj i√ßin √∂zel i≈üleme
    msg = update.message
    keyboard = []
    
    user_id = update.effective_user.id
    if user_id not in portfolio or not portfolio[user_id]:
        keyboard = [[InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await msg.reply_text("Hen√ºz portf√∂y√ºn√ºzde hisse bulunmuyor.", reply_markup=reply_markup)
        return
    
    # Portf√∂y bilgilerini hazƒ±rla
    portfolio_text = "üìä PORTF√ñY√úN√úZ:\n\n"
    total_investment = 0
    
    for symbol, data in portfolio[user_id].items():
        price = data['price']
        quantity = data['quantity']
        total = price * quantity
        total_investment += total
        
        portfolio_text += f"üî∏ {symbol}\n"
        portfolio_text += f"   Alƒ±m: {price} TL √ó {quantity} = {total:.2f} TL\n"
    
    portfolio_text += f"\nToplam Yatƒ±rƒ±m: {total_investment:.2f} TL"
    
    # Butonlarƒ± hazƒ±rla
    keyboard = []
    # Her hisse i√ßin bir silme butonu ekle
    for symbol in portfolio[user_id].keys():
        keyboard.append([InlineKeyboardButton(f"‚ùå {symbol} Sil", callback_data=f"delete_{symbol}")])
    
    keyboard.append([InlineKeyboardButton("üí∞ Gelir Durumu", callback_data="profit_loss")])
    keyboard.append([InlineKeyboardButton("Ana Men√º", callback_data="main_menu")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await msg.reply_text(portfolio_text, reply_markup=reply_markup)
    
# Gelir durumu komutu
async def profit_loss_command(update: Update, context: CallbackContext) -> None:
    await show_profit_loss(update.callback_query if hasattr(update, 'callback_query') else update.message, context)

# Bildirim ayarlarƒ± komutu
async def notification_settings_command(update: Update, context: CallbackContext) -> None:
    user_id = update.effective_user.id
    
    # Kullanƒ±cƒ±nƒ±n mevcut bildirim durumunu kontrol et
    current_status = "kapalƒ±"
    if user_id in notification_preferences and notification_preferences[user_id].get("enabled", False):
        current_status = "a√ßƒ±k"
    
    keyboard = [
        [InlineKeyboardButton("üîî Bildirimleri A√ß", callback_data="toggle_notifications")],
        [InlineKeyboardButton("‚ùå Bildirimleri Kapat", callback_data="stop_notifications")],
        [InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        f"Bildirim Ayarlarƒ±\n\n"
        f"Mevcut durum: {current_status}\n\n"
        f"Bildirimler hafta i√ßi (Pazartesi-Cuma) g√ºnleri\n"
        f"saat 09:00-18:00 arasƒ±nda, her saat ba≈üƒ±\n"
        f"otomatik olarak g√∂nderilir.",
        reply_markup=reply_markup
    )

# K√¢r-zarar g√∂sterme fonksiyonu
async def show_profit_loss(query, context: CallbackContext) -> None:
    user_id = query.from_user.id
    
    if user_id not in portfolio or not portfolio[user_id]:
        keyboard = [[InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("Hen√ºz portf√∂y√ºn√ºzde hisse bulunmuyor.", reply_markup=reply_markup)
        return
    
    await query.edit_message_text("G√ºncel fiyatlar alƒ±nƒ±yor, l√ºtfen bekleyin...")
    
    # K√¢r-zarar bilgilerini hazƒ±rla
    profit_loss_text = "üí∞ GELƒ∞R DURUMU:\n\n"
    total_investment = 0
    total_current_value = 0
    
    for symbol, data in portfolio[user_id].items():
        buy_price = data['price']
        quantity = data['quantity']
        total_buy = buy_price * quantity
        total_investment += total_buy
        
        # G√ºncel fiyatƒ± al
        current_price_text = await get_stock_price(symbol)
        # Fiyatƒ± metin i√ßinden √ßƒ±kar
        try:
            current_price_start = current_price_text.find("son fiyat: ") + len("son fiyat: ")
            current_price_str = current_price_text[current_price_start:].strip()
            # T√ºrk√ße formatta sayƒ±lar 1.234,56 ≈üeklinde olduƒüundan √∂nce noktalarƒ± kaldƒ±rƒ±p sonra virg√ºl√º noktaya √ßeviriyoruz
            current_price = float(current_price_str.replace('.', '').replace(',', '.'))
            
            total_current = current_price * quantity
            total_current_value += total_current
            
            profit_loss = total_current - total_buy
            profit_loss_percent = (profit_loss / total_buy) * 100 if total_buy > 0 else 0
            
            profit_loss_text += f"üîπ {symbol}\n"
            profit_loss_text += f"   Alƒ±m: {buy_price} TL √ó {quantity} = {total_buy:.2f} TL\n"
            profit_loss_text += f"   G√ºncel: {current_price} TL √ó {quantity} = {total_current:.2f} TL\n"
            
            if profit_loss >= 0:
                profit_loss_text += f"   K√¢r: +{profit_loss:.2f} TL (+{profit_loss_percent:.2f}%)\n\n"
            else:
                profit_loss_text += f"   Zarar: {profit_loss:.2f} TL ({profit_loss_percent:.2f}%)\n\n"
        except Exception as e:
            profit_loss_text += f"üîπ {symbol}\n"
            profit_loss_text += f"   Alƒ±m: {buy_price} TL √ó {quantity} = {total_buy:.2f} TL\n"
            profit_loss_text += f"   G√ºncel fiyat alƒ±namadƒ±\n\n"
    
    total_profit_loss = total_current_value - total_investment
    total_profit_loss_percent = (total_profit_loss / total_investment) * 100 if total_investment > 0 else 0
    
    profit_loss_text += f"Toplam Yatƒ±rƒ±m: {total_investment:.2f} TL\n"
    profit_loss_text += f"G√ºncel Deƒüer: {total_current_value:.2f} TL\n"
    
    if total_profit_loss >= 0:
        profit_loss_text += f"Toplam K√¢r: +{total_profit_loss:.2f} TL (+{total_profit_loss_percent:.2f}%)"
    else:
        profit_loss_text += f"Toplam Zarar: {total_profit_loss:.2f} TL ({total_profit_loss_percent:.2f}%)"
    
    keyboard = [
        [InlineKeyboardButton("üíº Portf√∂ye D√∂n", callback_data="my_portfolio")],
        [InlineKeyboardButton("Ana Men√º", callback_data="main_menu")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(profit_loss_text, reply_markup=reply_markup)

def main() -> None:
    # Portf√∂y verilerini y√ºkle
    load_portfolio()
    
    # Bildirim tercihlerini y√ºkle
    load_notification_preferences()
    
    # Bot uygulamasƒ±nƒ± olu≈ütur
    application = Application.builder().token(TOKEN).build()

    # Telegram Komut Men√ºs√º i√ßin komutlarƒ± ayarla
    bot_commands = [
        ("start", "Ana men√ºy√º g√∂ster"),
        ("help", "Yardƒ±m mesajƒ±nƒ± g√∂ster"),
        ("menu", "Ana men√ºy√º g√∂ster"),
        ("favoriler", "Favori hisselerinizi listele"),
        ("portfolio", "Portf√∂y√ºn√ºz√º g√∂ster"),
        ("gelir", "K√¢r-zarar durumunuzu g√∂ster"),
        ("bildirimler", "Otomatik bildirim ayarlarƒ±nƒ± y√∂net")
    ]
    
    # Uygulama ba≈ülatƒ±ldƒ±ƒüƒ±nda komutlarƒ± ayarla (post_init application nesnesini parametre olarak alƒ±r)
    async def post_init_setup(app):
        await app.bot.set_my_commands(bot_commands)
    
    # post_init hook'unu ayarla
    application.post_init = post_init_setup
    
    # Komut i≈üleyicileri
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("menu", start))  # menu komutu da ana men√ºy√º g√∂stersin
    application.add_handler(CommandHandler("ekle", add_favorite))
    application.add_handler(CommandHandler("favoriler", show_favorites))
    application.add_handler(CommandHandler("portfolio", portfolio_command))
    application.add_handler(CommandHandler("gelir", profit_loss_command))
    application.add_handler(CommandHandler("bildirimler", notification_settings_command))
    
    # D√ºƒüme geri √ßaƒürƒ±larƒ±
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # Metin mesajƒ± i≈üleyicisi
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Bot'u ba≈ülat
    application.run_polling()

if __name__ == '__main__':
    main()
